# 화폐 예제
1부에서는 테스트 주도 개발의 리듬을 알아보도록 한다. 리듬은 다음과 같이 요약할 수 있다.
1. 재빨리 테스트를 하나 추가한다.
2. 모든 테스트를 샐행하고 새로 추가한 것이 실패하는지 확인한다.
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
5. 리팩토링을 통해 중복을 제거한다. 

## 1장. 다중 통화를 자원하는 Money객체
> 요구사항
> * 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다. 
> * 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.

테스트를 먼저 만들어 보자.
```
public void testMultiplication() {
    Dollar five = new Dollar(5);
    five.times(2);
    assertEquals(10, five.amount);
}
```
위 코드는 컴파일 조차 되지 않는다. 다음의 총 네개의 컴파일 에러가 발생한다. 
* Dollar 클래스가 없음
* 생성자가 없음
* times(int) 메서드 없음
* amount 필드 없음

우선 컴파일이 되게하기 위해, 다음과 같이 코드를 작성헀다.

``` java
public class Dollar {

    int amount;

    public Dollar(int amount) {
    
    }

    void times(int multiplier) {
    
    }
}
```
컴파일 에러가 사라지고 테스트가 동작하지만, 테스트는 실패해 빨간 막대를 볼 수 있을 것이다. 이제 테스트를 통과시키도록 해보자.

``` java
    int amount = 10;
```
테스트가 성공해 초록색 막대를 보게 된다. 이제 위에서 말한 TDD 주기에 맞게 코드를 수정하자. 

``` java
public class Dollar {

    int amount;

    public Dollar(int amount) {
        this.amount = amount;
    }

    void times(int multiplier) {
        amount *= multiplier;
    }
}
```
이제 첫 번 째 테스트 완료 표시를 할 수 있게 됐다. 지금까지 한 작업은 다음과 같다. 
* 알고 있는 작업해야 할 테스트 목록을 만들었다.
* 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다. 
* Junit에 대한 상세한 사항들은 잠시 무시하기로 했다.
* 스텝 구현을 통해 테스트를 컴파일 했다.
* 끔찍한 죄악을 범하여 테스트를 통과시켰다.
* 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다. 
* 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어갔다. 